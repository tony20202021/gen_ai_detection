"""
Модуль визуализации эмбедингов и результатов кластеризации.
Каждая функция визуализирует результаты определенным способом.
"""

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pickle
from sklearn.manifold import TSNE
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from sklearn.metrics import confusion_matrix, silhouette_score, adjusted_rand_score
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import warnings
warnings.filterwarnings('ignore')

# Устанавливаем стиль для matplotlib
plt.style.use('ggplot')
sns.set_theme(style="whitegrid")


def load_data(task_num=2):
    """
    Загружает данные эмбедингов и результатов кластеризации для указанной задачи.
    
    Parameters:
    -----------
    task_num : int
        Номер задачи (1 или 2)
        
    Returns:
    --------
    tuple
        DataFrame с визуализационными данными и другие метрики
    """
    # Укажите пути к файлам с эмбедингами и результатами кластеризации
    TASK = task_num  # 1 или 2
    EMBEDDINGS_PATH = f'../data/embeddings/task{TASK}_embeddings_all-mpnet-base-v2_with_dim_reduction.pkl'
    CLUSTERING_PATH = f'../data/clustering/task{TASK}_kmeans_clustering_results.pkl'

    # Загрузка эмбедингов
    with open(EMBEDDINGS_PATH, 'rb') as f:
        embeddings_data = pickle.load(f)

    # Загрузка результатов кластеризации
    with open(CLUSTERING_PATH, 'rb') as f:
        clustering_data = pickle.load(f)

    # Извлечение данных
    embeddings = embeddings_data.get('embeddings')
    embeddings_tsne = embeddings_data.get('embeddings_tsne')
    metadata = embeddings_data.get('metadata')
    cluster_labels = clustering_data.get('cluster_labels')

    print(f"Загружено {len(embeddings)} эмбедингов размерности {embeddings.shape[1]}")
    print(f"Метаданные: {metadata.shape[0]} строк, {metadata.shape[1]} столбцов")
    if embeddings_tsne is not None:
        print(f"t-SNE эмбединги: {embeddings_tsne.shape}")
    else:
        print("t-SNE эмбединги отсутствуют, будут рассчитаны")
        
    # Определение колонки с метками в зависимости от задачи
    if TASK == 1:
        label_column = 'label'
    else:  # TASK == 2
        label_column = 'label_text' if 'label_text' in metadata.columns else 'label'

    # Объединение метаданных, эмбедингов и кластеров в один DataFrame
    if embeddings_tsne is not None:
        df_viz = pd.DataFrame(embeddings_tsne, columns=['tsne_1', 'tsne_2'])
    else:
        # Применяем t-SNE, если эмбединги t-SNE не были ранее рассчитаны
        print("Выполняется расчет t-SNE...")
        tsne = TSNE(n_components=2, perplexity=30, random_state=42, n_jobs=-1)
        embeddings_tsne = tsne.fit_transform(embeddings)
        df_viz = pd.DataFrame(embeddings_tsne, columns=['tsne_1', 'tsne_2'])

    # Добавляем метки и кластеры
    df_viz['true_label'] = metadata[label_column].values
    df_viz['cluster'] = cluster_labels
    df_viz['split'] = metadata['split'].values if 'split' in metadata.columns else 'unknown'

    # Создаем краткие версии меток для более удобного отображения
    label_mapping = {
        "human-written": "Человек",
        "human-initiated, then machine-continued": "Человек → ИИ",
        "human-written, then machine-polished": "Человек + ИИ (правка)",
        "machine-generated, then obfuscated": "ИИ + обфускация",
        "machine-generated, then human-edited": "ИИ → Человек",
        "deeply-mixed text; where some parts are written by a human and some are generated by a machine": "Смешанный текст"
    }

    # Создаем новый столбец с короткими метками для удобства
    df_viz['label_short'] = df_viz['true_label'].map(lambda x: label_mapping.get(x, x))

    # Если имеются дополнительные столбцы метаданных, добавляем их
    for col in metadata.columns:
        if col not in [label_column, 'split'] and col not in df_viz.columns:
            df_viz[col] = metadata[col].values

    return df_viz, embeddings, embeddings_tsne, metadata, cluster_labels, TASK


def visualize_tsne_basic(df_viz, task_num):
    """
    Создает базовую визуализацию t-SNE с истинными метками.
    
    Parameters:
    -----------
    df_viz : DataFrame
        DataFrame с данными для визуализации
    task_num : int
        Номер задачи (1 или 2)
    """
    plt.figure(figsize=(12, 10))

    # Определяем, какой столбец использовать для визуализации
    if task_num == 1:
        # Для задачи 1 (бинарная классификация) используем числовые метки
        hue_column = "true_label"
        palette = {0: "#2077B4", 1: "#FF7F0E"}
        label_dict = {0: "Человек", 1: "ИИ"}
        
        # Создаем scatter plot с использованием seaborn
        ax = sns.scatterplot(
            data=df_viz,
            x="tsne_1",
            y="tsne_2",
            hue=hue_column,
            palette=palette,
            alpha=0.7,
            s=50,
            edgecolor="w",
            linewidth=0.5
        )
        
        # Обновляем легенду с понятными названиями классов для задачи 1
        handles, labels = ax.get_legend_handles_labels()
        updated_labels = [label_dict.get(int(label), label) for label in labels]
        ax.legend(handles, updated_labels, title="Класс", fontsize=12, title_fontsize=14)
        
    else:
        # Для задачи 2 (многоклассовая) используем короткие метки
        hue_column = "label_short"
        
        # Создаем scatter plot с использованием seaborn
        ax = sns.scatterplot(
            data=df_viz,
            x="tsne_1",
            y="tsne_2",
            hue=hue_column,
            palette="husl",
            alpha=0.7,
            s=50,
            edgecolor="w",
            linewidth=0.5
        )
        
        # Используем стандартную легенду для задачи 2
        plt.legend(title="Класс", fontsize=12, title_fontsize=14)

    # Настройка графика
    plt.title(f"t-SNE визуализация эмбедингов с истинными метками (Задача {task_num})", fontsize=16)
    plt.xlabel("t-SNE компонента 1", fontsize=14)
    plt.ylabel("t-SNE компонента 2", fontsize=14)

    plt.tight_layout()
    plt.show()


def visualize_tsne_interactive(df_viz, task_num):
    """
    Создает интерактивную визуализацию t-SNE с помощью Plotly.
    
    Parameters:
    -----------
    df_viz : DataFrame
        DataFrame с данными для визуализации
    task_num : int
        Номер задачи (1 или 2)
    """
    # Создаем интерактивный график с Plotly
    if task_num == 1:
        color_column = "true_label"
        color_discrete_map = {0: "#2077B4", 1: "#FF7F0E"}
        hover_data = ["true_label", "cluster", "split"]
        category_orders = {"true_label": sorted(df_viz["true_label"].unique())}
        title = "t-SNE визуализация эмбедингов (бинарная классификация)"
        label_name = "Класс"
    else:
        color_column = "label_short"
        color_discrete_map = None  # Автоматическая цветовая схема
        # Проверяем, какие столбцы действительно есть в df_viz
        available_columns = df_viz.columns.tolist()
        hover_data = ["true_label", "cluster", "split", "source_dataset"]
        if "model" in available_columns:
            hover_data.append("model")
        category_orders = {"label_short": sorted(df_viz["label_short"].unique())}
        title = "t-SNE визуализация эмбедингов (многоклассовая классификация)"
        label_name = "Класс"

    fig = px.scatter(
        df_viz, 
        x="tsne_1", 
        y="tsne_2", 
        color=color_column,
        color_discrete_map=color_discrete_map,
        category_orders=category_orders,
        hover_name=df_viz.index,
        hover_data=hover_data,
        title=title,
        labels={"tsne_1": "t-SNE компонента 1", "tsne_2": "t-SNE компонента 2", color_column: label_name},
        opacity=0.7,
        size_max=10,
        template="plotly_white"
    )

    fig.update_layout(
        width=1000,
        height=800,
        legend=dict(title=label_name, orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        margin=dict(l=20, r=20, t=60, b=20)
    )

    fig.show()


def visualize_labels_vs_clusters(df_viz, task_num):
    """
    Создает визуализацию, сравнивающую истинные метки и результаты кластеризации.
    
    Parameters:
    -----------
    df_viz : DataFrame
        DataFrame с данными для визуализации
    task_num : int
        Номер задачи (1 или 2)
    """
    # Создаем два графика: с истинными метками и с кластерами
    fig, axes = plt.subplots(1, 2, figsize=(20, 8))

    # Определяем, какой столбец использовать для визуализации истинных меток
    if task_num == 1:
        # Для задачи 1 (бинарная классификация)
        hue_column = "true_label"
        palette_for_labels = {0: "#2077B4", 1: "#FF7F0E"}
        
        # График с истинными метками
        sns.scatterplot(
            data=df_viz,
            x="tsne_1",
            y="tsne_2",
            hue=hue_column,
            palette=palette_for_labels,
            alpha=0.7,
            s=50,
            edgecolor="w",
            linewidth=0.5,
            ax=axes[0]
        )
        
        # Обновляем легенду с понятными названиями классов
        handles, labels = axes[0].get_legend_handles_labels()
        label_dict = {0: "Человек", 1: "ИИ"}
        updated_labels = [label_dict.get(int(label), label) for label in labels]
        axes[0].legend(handles, updated_labels, title="Класс", fontsize=12, title_fontsize=14)
    else:
        # Для задачи 2 (многоклассовая классификация)
        hue_column = "label_short"
        
        # График с истинными метками
        sns.scatterplot(
            data=df_viz,
            x="tsne_1",
            y="tsne_2",
            hue=hue_column,
            palette="husl",
            alpha=0.7,
            s=50,
            edgecolor="w",
            linewidth=0.5,
            ax=axes[0]
        )
        
        # Используем стандартную легенду
        axes[0].legend(title="Класс", fontsize=12, title_fontsize=14)

    axes[0].set_title("Истинные метки", fontsize=16)
    axes[0].set_xlabel("t-SNE компонента 1", fontsize=14)
    axes[0].set_ylabel("t-SNE компонента 2", fontsize=14)

    # График с результатами кластеризации (этот код работает для обеих задач без изменений)
    cluster_palette = sns.color_palette("bright", len(df_viz['cluster'].unique()))
    sns.scatterplot(
        data=df_viz,
        x="tsne_1",
        y="tsne_2",
        hue="cluster",
        palette=cluster_palette,
        alpha=0.7,
        s=50,
        edgecolor="w",
        linewidth=0.5,
        ax=axes[1]
    )
    axes[1].set_title("Результаты кластеризации", fontsize=16)
    axes[1].set_xlabel("t-SNE компонента 1", fontsize=14)
    axes[1].set_ylabel("t-SNE компонента 2", fontsize=14)

    plt.tight_layout()
    plt.show()


def analyze_cluster_metrics(df_viz, embeddings_tsne):
    """
    Анализирует метрики качества кластеризации и визуализирует соответствие 
    кластеров истинным меткам.
    
    Parameters:
    -----------
    df_viz : DataFrame
        DataFrame с данными для визуализации
    embeddings_tsne : ndarray
        Эмбединги после применения t-SNE
    """
    # Вычисляем матрицу соответствия
    cluster_label_matrix = pd.crosstab(df_viz['cluster'], df_viz['true_label'])

    # Нормализуем по строкам (процент каждого класса в кластере)
    cluster_label_matrix_norm = cluster_label_matrix.div(cluster_label_matrix.sum(axis=1), axis=0) * 100

    # Отображаем матрицу соответствия
    plt.figure(figsize=(12, 8))
    sns.heatmap(cluster_label_matrix_norm, annot=True, cmap="YlGnBu", fmt=".1f")
    plt.title("Соответствие кластеров истинным меткам (% распределения)", fontsize=16)
    plt.xlabel("Истинные метки", fontsize=14)
    plt.ylabel("Кластеры", fontsize=14)
    plt.tight_layout()
    plt.show()

    # Вычисляем метрики качества кластеризации
    ari = adjusted_rand_score(df_viz['true_label'], df_viz['cluster'])
    silhouette = silhouette_score(embeddings_tsne, df_viz['cluster'])

    print(f"Adjusted Rand Index: {ari:.4f}")
    print(f"Силуэтный коэффициент: {silhouette:.4f}")


def visualize_pca(df_viz, embeddings, task_num):
    """
    Создает визуализацию с использованием PCA для анализа разделимости классов.
    
    Parameters:
    -----------
    df_viz : DataFrame
        DataFrame с данными для визуализации
    embeddings : ndarray
        Исходные эмбединги
    task_num : int
        Номер задачи (1 или 2)
    """
    # Стандартизация эмбедингов
    scaler = StandardScaler()
    embeddings_scaled = scaler.fit_transform(embeddings)

    # Применение PCA для извлечения главных компонент
    pca = PCA(n_components=2)
    embeddings_pca = pca.fit_transform(embeddings_scaled)

    # Создаем DataFrame для визуализации
    df_pca = pd.DataFrame(embeddings_pca, columns=['PC1', 'PC2'])

    # Добавляем соответствующие метки в зависимости от задачи
    if task_num == 1:
        df_pca['label_for_viz'] = df_viz['true_label']
        palette_for_pca = {0: "#2077B4", 1: "#FF7F0E"}
    else:
        df_pca['label_for_viz'] = df_viz['label_short']
        palette_for_pca = sns.color_palette("husl", len(df_viz['label_short'].unique()))

    # Визуализация PCA
    plt.figure(figsize=(12, 10))
    sns.scatterplot(
        data=df_pca,
        x="PC1",
        y="PC2",
        hue="label_for_viz",
        palette=palette_for_pca,
        alpha=0.7,
        s=50,
        edgecolor="w",
        linewidth=0.5
    )
    plt.title(f"PCA визуализация эмбедингов (Задача {task_num})", fontsize=16)
    plt.xlabel(f"PC1 ({pca.explained_variance_ratio_[0]*100:.1f}%)", fontsize=14)
    plt.ylabel(f"PC2 ({pca.explained_variance_ratio_[1]*100:.1f}%)", fontsize=14)

    # Настройка легенды в зависимости от задачи
    if task_num == 1:
        handles, labels = plt.gca().get_legend_handles_labels()
        label_dict = {0: "Человек", 1: "ИИ"}
        updated_labels = [label_dict.get(int(label), label) for label in labels]
        plt.legend(handles, updated_labels, title="Класс", fontsize=12, title_fontsize=14)
    else:
        plt.legend(title="Класс", fontsize=12, title_fontsize=14)

    plt.tight_layout()
    plt.show()

    # Объясненная дисперсия
    print(f"Объясненная дисперсия первыми двумя компонентами: {sum(pca.explained_variance_ratio_[:2])*100:.2f}%")


def analyze_clustering_errors(df_viz, task_num):
    """
    Анализирует и визуализирует ошибочно кластеризованные примеры.
    
    Parameters:
    -----------
    df_viz : DataFrame
        DataFrame с данными для визуализации
    task_num : int
        Номер задачи (1 или 2)
    """
    # Адаптируем код в зависимости от типа задачи
    if task_num == 1:
        label_column_for_cluster = 'true_label'
        # Для задачи 1 определяем цветовую палитру и словарь меток
        palette_for_errors = {0: "#2077B4", 1: "#FF7F0E"}
        class_names = {0: "Человек", 1: "ИИ"}
    else:
        label_column_for_cluster = 'label_short'
        # Для задачи 2 создаем палитру и словарь меток
        palette_for_errors = {label: sns.color_palette("husl", len(df_viz[label_column_for_cluster].unique()))[i] 
                             for i, label in enumerate(sorted(df_viz[label_column_for_cluster].unique()))}
        class_names = {label: label for label in df_viz[label_column_for_cluster].unique()}

    # Определяем отображение кластеров на классы
    cluster_to_class = {}
    for cluster in df_viz['cluster'].unique():
        # Для каждого кластера находим наиболее частый класс
        cluster_mask = df_viz['cluster'] == cluster
        class_counts = df_viz.loc[cluster_mask, label_column_for_cluster].value_counts()
        most_common_class = class_counts.index[0]
        cluster_to_class[cluster] = most_common_class

    # Определяем правильно и неправильно кластеризованные примеры
    df_viz['predicted_class'] = df_viz['cluster'].map(cluster_to_class)
    df_viz['correctly_clustered'] = df_viz['predicted_class'] == df_viz[label_column_for_cluster]

    # Анализ ошибочно кластеризованных примеров
    incorrect_df = df_viz[~df_viz['correctly_clustered']]
    print(f"Всего примеров: {len(df_viz)}")
    print(f"Правильно кластеризованных: {len(df_viz[df_viz['correctly_clustered']])} ({len(df_viz[df_viz['correctly_clustered']])/len(df_viz)*100:.2f}%)")
    print(f"Неправильно кластеризованных: {len(incorrect_df)} ({len(incorrect_df)/len(df_viz)*100:.2f}%)")

    # Визуализация ошибочно кластеризованных примеров
    plt.figure(figsize=(12, 10))
    correct_mask = df_viz['correctly_clustered']

    # Сначала отображаем правильно кластеризованные примеры (серым цветом)
    plt.scatter(
        df_viz.loc[correct_mask, 'tsne_1'],
        df_viz.loc[correct_mask, 'tsne_2'],
        c='lightgray',
        alpha=0.3,
        s=30,
        label='Правильно кластеризованные'
    )

    # Затем отображаем неправильно кластеризованные примеры (цветами по истинным меткам)
    for label in df_viz[label_column_for_cluster].unique():
        mask = (~correct_mask) & (df_viz[label_column_for_cluster] == label)
        if sum(mask) > 0:  # Проверяем, есть ли точки с такой меткой
            plt.scatter(
                df_viz.loc[mask, 'tsne_1'],
                df_viz.loc[mask, 'tsne_2'],
                c=[palette_for_errors[label]],
                alpha=0.8,
                s=100,
                edgecolor='black',
                linewidth=1,
                label=f'Класс: {class_names[label]}'
            )

    plt.title("Ошибочно кластеризованные примеры", fontsize=16)
    plt.xlabel("t-SNE компонента 1", fontsize=14)
    plt.ylabel("t-SNE компонента 2", fontsize=14)
    plt.legend(fontsize=12)
    plt.tight_layout()
    plt.show()

    # Анализ характеристик ошибочно кластеризованных примеров
    if 'model' in incorrect_df.columns:
        print("\nРаспределение ошибочно кластеризованных примеров по моделям:")
        print(incorrect_df['model'].value_counts(normalize=True) * 100)

    if 'source_dataset' in incorrect_df.columns:
        print("\nРаспределение ошибочно кластеризованных примеров по источникам данных:")
        print(incorrect_df['source_dataset'].value_counts(normalize=True) * 100)

    print("\nРаспределение ошибочно кластеризованных примеров по выборкам:")
    print(incorrect_df['split'].value_counts(normalize=True) * 100)

    # Отображаем распределение ошибочно кластеризованных примеров по истинным классам
    print("\nРаспределение ошибочно кластеризованных примеров по истинным классам:")
    if task_num == 1:
        print(incorrect_df['true_label'].map({0: "Человек", 1: "ИИ"}).value_counts(normalize=True) * 100)
    else:
        print(incorrect_df['label_short'].value_counts(normalize=True) * 100)


def main(task_num=2):
    """
    Основная функция для запуска всех визуализаций для указанной задачи.
    
    Parameters:
    -----------
    task_num : int
        Номер задачи (1 или 2)
    """
    # Загрузка данных
    df_viz, embeddings, embeddings_tsne, metadata, cluster_labels, task = load_data(task_num)
    
    # Базовая визуализация t-SNE
    visualize_tsne_basic(df_viz, task)
    
    # Интерактивная визуализация t-SNE
    visualize_tsne_interactive(df_viz, task)
    
    # Сравнение истинных меток с кластерами
    visualize_labels_vs_clusters(df_viz, task)
    
    # Анализ метрик кластеризации
    analyze_cluster_metrics(df_viz, embeddings_tsne)
    
    # Визуализация PCA
    visualize_pca(df_viz, embeddings, task)
    
    # Анализ ошибочно кластеризованных примеров
    analyze_clustering_errors(df_viz, task)


if __name__ == "__main__":
    # Пример использования
    main(task_num=2)  # Выберите задачу 1 или 2
